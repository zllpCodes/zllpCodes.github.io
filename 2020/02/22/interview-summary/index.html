<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!--Description-->
  
  <meta name="description" content="用于存放技术学习的总结、阅读后的感想以及生活中的点滴">
  

  <!--Author-->
  
  <meta name="author" content="Zhang Linlin">
  

  <!--Open Graph Title-->
  
      <meta property="og:title" content="前端知识点总结">
  
  <!--Open Graph Description-->
  
      <meta property="og:description" content="用于存放技术学习的总结、阅读后的感想以及生活中的点滴">
  
  <!--Open Graph Site Name-->
  <meta property="og:site_name" content="张琳琳个人网站">
  <!--Type page-->
  
      <meta property="og:type" content="article">
  
  <!--Page Cover-->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- Title -->
  
  <title>前端知识点总结 - 张琳琳个人网站</title>


  <link rel="shortcut icon" href="https://zhanglinlin-site-1258125238.cos.ap-beijing.myqcloud.com/favicon.ico">

  <!-- Custom CSS/Sass -->
  <link rel="stylesheet" href="/css/style.css">

</head>


<body>

  <!-- Nav -->
  <header class="site-header">
  <div class="header-inside">
    <div class="logo">
      <a href="/" rel="home">
        
        <img src="https://zhanglinlin-site-1258125238.cos.ap-beijing.myqcloud.com/logo.png" alt="张琳琳个人网站" height="60">
        
      </a>
    </div>
    <!-- Navigation -->
    <nav class="navbar">
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse">
        <ul class="navbar-nav">
          
          
            <li>
              <a href="/.">
                
                  Home
                
              </a>
            </li>
          
            <li>
              <a href="/archives">
                
                  Archive
                
              </a>
            </li>
          
            <li>
              <a href="/about">
                
                  About
                
              </a>
            </li>
          
        </ul>
      </div>
      <!-- /.navbar-collapse -->
    </nav>
    <div class="button-wrap">
      <button class="menu-toggle">Primary Menu</button>
    </div>
  </div>
</header>


  <!-- Main Content -->
  <div class="content-area">
  <div class="post">
    <!-- Post Content -->
    <div class="container">
      <article>
        <!-- Title date & tags -->
        <div class="post-header">
          <h1 class="entry-title">
            前端知识点总结
            
          </h1>
          <p class="posted-on">
            
                2020-02-22
            
          </p>
          <div class="tags-links">
            
              
                <a href="/tags/技术/" rel="tag">
                  技术
                </a>
              
                <a href="/tags/前端/" rel="tag">
                  前端
                </a>
              
            
          </div>
        </div>
        <!-- Post Main Content -->
        <div class="entry-content has_line_number">
          <h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p><strong>this</strong></p>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">Javascript 的 this 用法</a></li>
</ul>
<p><strong>创建对象</strong></p>
<p>工厂模式<br>优点：快速创建多个类似对象<br>缺点：无法识别对象的类型</p>
<pre><code>// 工厂模式
function createPerson(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;

    o.sayHi = function () {
        alert(&apos;Into the unknow!&apos;);
    };

    return o;
}

var p1 = createPerson(&apos;Elsa&apos;, 24, &apos;queen&apos;);
p1.sayHi(); // &apos;Into the unknow!&apos;
</code></pre><p>构造函数模式<br>优点：可以将实例标识为特定的类型<br>缺点：浪费资源，创造同名不相等的函数</p>
<pre><code>// 构造函数模式
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayHi = function () {
        alert(&apos;Hi! I\&apos;m &apos; + this.name);
    };
}

var p1 = new Person(&apos;Elsa&apos;, 24, &apos;queen&apos;),
    p2 = new Person(&apos;Anna&apos;, 21, &apos;princess&apos;);

alert(p1 instanceof Person); // true
alert(p2 instanceof Person); // true
alert(p1.sayHi == p2.sayHi); // false
</code></pre><p>原型模式<br>优点：节约资源，包含在原型对象上的属性和方法可以被同类型的实例访问<br>缺点：不同实例对原型上引用类型的属性进行修改，造成意外结果</p>
<pre><code>// 原型模式
function Person() {}

Person.prototype.name = &apos;Elsa&apos;;
Person.prototype.age = 24;
Person.prototype.job = &apos;queen&apos;;
Person.prototype.sayHi = function () {
    alert(&apos;Into the unknow!&apos;);
};

var p1 = new Person(),
    p2 = new Person();

p1.sayHi(); // &apos;Into the unknow!&apos;
alert(p1.sayHi == p2.sayHi); // true
</code></pre><p>构造函数模式+原型模式<br>是当前最常用的创建对象的模式，结合了构造函数模式和原型模式的优点。</p>
<pre><code>// 构造函数模式+原型模式
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
}

Person.prototype.sayHi = function () {
    alert(&apos;Hi! I\&apos;m &apos; + this.name);
};

// 或者采用以下对象字面量的写法
Person.prototype = {
    constructor: Person, // 此行必须！否则可能导致实例类型归属有误
    sayHi: function () {
        alert(&apos;Hi! I\&apos;m &apos; + this.name);
    }
};

var p1 = new Person(&apos;Elsa&apos;, 24, &apos;queen&apos;),
    p2 = new Person(&apos;Anna&apos;, 21, &apos;princess&apos;);

alert(p1 instanceof Person); // true
alert(p2 instanceof Person); // true
alert(p1.sayHi == p2.sayHi); // true
</code></pre><p><em>以下模式都是在特定情况下对工厂模式、构造函数模式、原型模式的结合和优化。</em></p>
<p>寄生构造函数模式非常像工厂模式，但是调用方法类似构造函数模式。<br>一般构造函数在不返回值的情况下默认返回新对象实例，若在构造函数添加return，则可以改写返回值。</p>
<pre><code>// 寄生构造函数模式
function Person(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;

    o.sayHi = function () {
        alert(&apos;Into the unknow!&apos;);
    };

    return o; // 改写构造函数返回的对象实例
}

var p1 = new Person(&apos;Elsa&apos;, 24, &apos;queen&apos;);
p1.sayHi(); // &apos;Into the unknow!&apos;
</code></pre><p>这个模式常用来为，内置对象创建自定义对象构造函数。</p>
<pre><code>// 实际运用
function SpecialArray() {
    var values = new Array();

    values.push.apply(values, arguments);

    values.toPipedString = function() {
        return this.join(&apos;|&apos;);
    };

    return values;
}

var colors = new SpecialArray(&apos;red&apos;, &apos;blue&apos;, &apos;yellow&apos;);
alert(colors.toPipedString()); // &apos;red|blue|yellow&apos;
</code></pre><p>稳妥对象：没有公共属性且其方法不引用this的对象。<br>稳妥构造函数模式使得除了调用sayHi()外没有别的方式访问其数据成员。<br>该模式提供的安全性，使得它非常适合在某些安全执行环境下使用。</p>
<pre><code>// 稳妥构造函数模式
function Person(name, age, job) {
    var o = new Object();

    o.sayHi = function () {
        alert(name);
    };

    return o;
}

var p1 = Person(&apos;Elsa&apos;, 24, &apos;queen&apos;);
p1.sayHi(); // &apos;Elsa&apos;
</code></pre><p>使用动态原型模式时，不能使用对象字面量重新改写原型！</p>
<pre><code>// 动态原型模式
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;

    if(typeof this.sayHi != &apos;function&apos;) {
        Person.prototype.sayHi = function () {
            alert(&apos;Hi! I\&apos;m &apos; + this.name);
        };
    }
}

var p1 = Person(&apos;Elsa&apos;, 24, &apos;queen&apos;);
p1.sayHi(); // &quot;Hi! I&apos;m Elsa&quot;
</code></pre><p><strong>继承</strong></p>
<p>原型链继承<br>优点：具有清晰的继承关系，实例与其继承的对象类型可以通过instanceof进行判断<br>缺点：</p>
<ol>
<li>包含引用类型属性的原型被其实例共有，可能造成意外修改</li>
<li>创建子类型的实例时，无法向超类型的构造函数传递参数</li>
</ol>
<pre><code>// 原型链继承
function SuperType() {
    this.property = true;
}

SuperType.prototype.getSuperValue = function() {
    return this.property;
}

function SubType() {
    this.subProperty = false;
}

SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function() {
    return this.subProperty;
}

var instance = new SubType();
alert(instance.getSuperValue()); // true
alert(instance instanceof SuperType); // true
alert(instance instanceof SubType); // true
</code></pre><p>借用构造函数继承<br>优点：可以在子类型构造函数中向超类型构造函数传递参数<br>缺点：在超类型的原型中定义的方法，对子类型而言不可见</p>
<pre><code>// 借用构造函数继承
function SuperType(name) {
    this.name = name;
    this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;yellow&apos;];
}

function SubType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}

var instance = new SubType(&apos;Elsa&apos;, 24);
alert(instance.name); // &apos;Elsa&apos;
alert(instance.colors); // &apos;red,blue,yellow&apos;
</code></pre><p>组合继承<br>优点：结合了原型链继承和借用构造函数继承的优势，互补了它们的缺点，是最常用的继承方法<br>缺点：浪费资源，在子类型的实例和原型对象上都有同样的超类型的实例属性</p>
<pre><code>// 组合继承
function SuperType(name) {
    this.name = name;
    this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;yellow&apos;];
}

SuperType.prototype.sayName = function() {
    alert(this.name);
};

function SubType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}

SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType; // 更正子类型的构造函数指向
SubType.prototype.sayAge = function() {
    alert(this.age);
};

var instance1 = new SubType(&apos;Elsa&apos;, 24);
instance1.colors.push(&apos;green&apos;);
alert(instance1.colors); // &apos;red,blue,yellow,green&apos;

var instance2 = new SubType(&apos;Anna&apos;, 21);
alert(instance2.colors); // &apos;red,blue,yellow&apos;
</code></pre><p>原型式继承<br>优点：若只是需要某对象与另一对象保持相似，可以不必要创建构造函数、原型对象<br>缺点：可能造成多个实例对原型对象上引用类型属性的意外修改</p>
<pre><code>// 原型式继承
function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}

var person = {
    name: &apos;Elsa&apos;,
    friends: [&apos;Anna&apos;, &apos;Olaf&apos;, &apos;Nokk&apos;]
};

var anotherPerson = object(person);
anotherPerson.name = &apos;Anna&apos;;
anotherPerson.friends.push(&apos;Seven&apos;);

alert(anotherPerson.name); // &apos;Anna&apos;
alert(person.friends); // &apos;Anna,Olaf,Nokk,Seven&apos;
</code></pre><p>ECMAScript5新增Object.create()方法规范了原型式继承。</p>
<pre><code>// 调用Object.create()进行继承
var person = {
    name: &apos;Elsa&apos;,
    friends: [&apos;Anna&apos;, &apos;Olaf&apos;, &apos;Nokk&apos;]
};

var anotherPerson = Object.create(person);
anotherPerson.name = &apos;Anna&apos;;
anotherPerson.friends.push(&apos;Seven&apos;);

alert(anotherPerson.name); // &apos;Anna&apos;
alert(person.friends); // &apos;Anna,Olaf,Nokk,Seven&apos;
</code></pre><p>寄生式继承<br>优点：若只是需要某对象与另一对象保持相似，可以不必要创建构造函数、原型对象<br>缺点：无法函数复用，导致资源浪费</p>
<pre><code>// 寄生式继承
function createAnother(original) {
    var clone = object(original);
    clone.sayHi = function() {
        alert(&apos;Into the unknow!&apos;);
    };
    return clone;
}

var person = {
    name: &apos;Elsa&apos;,
    friends: [&apos;Anna&apos;, &apos;Olaf&apos;, &apos;Nokk&apos;]
};

var anotherPerson = createAnother(person);
anotherPerson.sayHi(); // &apos;Into the unknow!&apos;
</code></pre><p>寄生组合式继承<br>优点：克服了组合继承实例和原型对象上重复实例属性的问题，是最理想的继承实现</p>
<pre><code>// 寄生组合式继承
function inheritPrototype(subType, superType) {
    var prototype = object(superType); // 创建对象
    prototype.constructor = subType; // 指向正确的constructor
    subType.prototype = prototype; // 指定原型对象
}

function SuperType(name) {
    this.name = name;
    this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;yellow&apos;];
}

SuperType.prototype.sayName = function() {
    alert(this.name);
};

function SubType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}

// 确定原型链
inheritPrototype(SubType, SupperType);
SubType.prototype.sayAge = function() {
    alert(this.age);
};
</code></pre><p><strong>执行环境与作用域</strong></p>
<pre><code>执行环境定义了变量或函数的有权访问的其他数据，决定了它们各自的行为。
每个函数都有自己的执行环境。
每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。
当代码在一个环境中执行时，会创建变量对象的一个作用域链。
作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。
作用域链的前端，始终是当前执行的代码所在环境的变量对象。
下一个变量对象是外部环境，一直延伸到全局执行环境。
标识符解析是沿着作用域一级一级搜索的过程，始终从作用域链前端开始，逐级向后，直到找到标识符为止。
如果找不到标识符，通常会导致错误发生。
</code></pre><p><strong>闭包</strong></p>
<pre><code>function outer(name) {
    return function () {
        console.log(name);
    }
}

outer(&apos;vivi&apos;)(); // vivi

在outer函数执行完后，其活动对象不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。
因此称这个匿名函数为闭包。
</code></pre><p><strong>递归</strong></p>
<pre><code>// Description
You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. 
In how many distinct ways can you climb to the top?

// Solution
const recurse = function f(n) {
    if(n == 0) return 0;
    if(n == 1) return 1;
    if(n == 2) return 2;

    return f(n - 1) + f(n - 2);
};

recurse(5); // 8 
</code></pre><p><strong>MVC MVP MVVM</strong></p>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/64257809" target="_blank" rel="noopener">结合vue、react、angular谈谈MVC、MVP、MVVM框架</a></li>
</ul>
<hr>
<h2 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML + CSS"></a>HTML + CSS</h2><p><strong>左右布局</strong></p>
<p>左右等宽</p>
<pre><code>// HTML
&lt;div class=&quot;wrapper&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;aaaaaa&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;bbbbb&lt;/div&gt;
&lt;/div&gt;

// float实现
.wrapper {
    overflow: hidden;
}

.left {
    float: left;
    width: 50%;
    height: 100px;
    background-color: red;
}

.right {
    float: left;
    width: 50%;
    height: 100px;
    background-color: blue;
}
</code></pre><p>左侧固定宽度，右侧自适应</p>
<pre><code>// HTML
&lt;div class=&quot;wrapper&quot;&gt;
    &lt;div class=&quot;left&quot;&gt;aaaaaa&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;bbbbb&lt;/div&gt;
&lt;/div&gt;

// CSS
.wrapper {
    overflow: hidden;
}

.left {
    float: left;
    width: 100px;
    height: 100px;
    background-color: red;
}

.right {
    width: auto; /* 可以不设置，默认为auto */
    height: 100px;
    background-color: blue;
}
</code></pre><p>右侧固定宽度，左侧自适应</p>
<pre><code>// HTML
&lt;div class=&quot;wrapper&quot;&gt;
    &lt;div class=&quot;right&quot;&gt;bbbbb&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;aaaaaa&lt;/div&gt;
&lt;/div&gt;

// CSS
.wrapper {
    overflow: hidden;
}

.left {
    width: auto;
    height: 100px;
    background-color: red;
}

.right {
    float: right;
    width: 100px; /* 可以不设置，默认为auto */
    height: 100px;
    background-color: blue;
}
</code></pre><p><strong>圣杯布局</strong></p>
<pre><code>// HTML
&lt;div class=&quot;wrapper&quot;&gt;
    &lt;div class=&quot;middle&quot;&gt;aaaaaaa&lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;bbbbb&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;cccc&lt;/div&gt;
&lt;/div&gt;

// CSS
// padding-left为.left框的宽度
// padding-right为.right框的宽度
.wrapper {
    padding: 0 100px; 
    overflow: hidden;
}

.middle {
    float: left;
    width: 100%;
    height: 100px;
    background: yellow;
}

// position: relative;相对于自身进行定位
// left的距离为负的.left框的宽度
.left {
    position: relative;
    left: -100px;
    float: left;
    width: 100px;
    height: 100px;
    margin-left: -100%;
    background: red;
}

// right的距离为负的.right框的宽度
.right {
    position: relative;
    right: -100px;
    float: left;
    width: 100px;
    height: 100px;
    margin-left: -100px;
    background: blue;
}
</code></pre><p><strong>双飞翼布局</strong></p>
<pre><code>// HTML
// 注意.middle框要放在.left和.right框的前面渲染
&lt;div class=&quot;wrapper&quot;&gt;
    &lt;div class=&quot;middle&quot;&gt;
        &lt;div class=&quot;inner&quot;&gt;aaaaaaa&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;left&quot;&gt;bbbbb&lt;/div&gt;
    &lt;div class=&quot;right&quot;&gt;cccc&lt;/div&gt;
&lt;/div&gt;

// CSS
.wrapper {
    overflow: hidden;
}

.middle {
    float: left;
    width: 100%;
    height: 100px;
    background: yellow;
}

// 使用margin将左右两个框的宽度隔开，防止内容遮挡
.inner {
    margin-left: 100px;
    margin-right: 100px; 
    word-break: break-all;
}

.left {
    float: left;
    width: 100px;
    height: 100px;
    margin-left: -100%; // 将.left框上移一行
    background: red;
}

.right {
    float: left;
    width: 100px;
    height: 100px;
    margin-left: -100px; // 将.right框上移一个自身的宽度
    background: blue;
}
</code></pre><p><strong>水平垂直居中</strong></p>
<p>display: flex实现</p>
<pre><code>// HTML
&lt;div class=&quot;outer&quot;&gt;
    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

// CSS
.outer {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 500px;
    height: 500px;
    background: red;
}

.inner {
    width: 100px;
    height: 100px;
    background: yellow;
}
</code></pre><p><strong>变形</strong><br><strong>过渡</strong><br><strong>动画</strong><br><strong>画布</strong></p>
<hr>
<h2 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h2><p><strong>Webpack</strong></p>
<ul>
<li><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">Webpack中文文档</a></li>
</ul>
<p><strong>Gulp</strong></p>
<ul>
<li><a href="https://www.gulpjs.com.cn/docs/getting-started/quick-start/" target="_blank" rel="noopener">Gulp快速入门</a></li>
</ul>
<p><strong>Git</strong></p>
<ul>
<li><a href="https://zhanglinlin.site/2019/06/14/git-summary/">Git常用命令总结</a></li>
</ul>
<hr>
<h2 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h2><p><strong>Vue</strong></p>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue教程</a></li>
</ul>
<p><strong>React</strong></p>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/getting-started.html" target="_blank" rel="noopener">React文档</a></li>
</ul>
<p><strong>Sass</strong></p>
<ul>
<li><a href="https://www.sass.hk/docs/" target="_blank" rel="noopener">Sass中文文档</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2012/06/sass.html" target="_blank" rel="noopener">SASS用法指南</a></li>
</ul>
<p><strong>Less</strong></p>
<ul>
<li><a href="https://less.bootcss.com/" target="_blank" rel="noopener">Less官方手册</a></li>
</ul>
<p><strong>小程序</strong></p>
<ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">小程序开发指南</a></li>
</ul>
<p><strong>jQuery</strong></p>
<ul>
<li><a href="https://www.jquery123.com/" target="_blank" rel="noopener">jQuery API中文文档</a></li>
</ul>
<p><strong>Bootstrap</strong></p>
<ul>
<li><a href="https://v3.bootcss.com/components/#" target="_blank" rel="noopener">Bootstrap中文文档</a></li>
</ul>
<hr>
<h2 id="Supplementary"><a href="#Supplementary" class="headerlink" title="Supplementary"></a>Supplementary</h2><p><strong>NodeJs</strong></p>
<ul>
<li><a href="http://nodejs.cn/api/" target="_blank" rel="noopener">Node.js文档</a></li>
</ul>
<p><strong>i18Next</strong></p>
<ul>
<li><a href="https://www.i18next.com/overview/api" target="_blank" rel="noopener">i18next documentation</a></li>
</ul>
<p><strong>Echarts</strong></p>
<ul>
<li><a href="https://www.echartsjs.com/zh/api.html#echarts" target="_blank" rel="noopener">Echarts API文档</a></li>
</ul>
<hr>
<h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><p><strong>数组</strong></p>
<pre><code>数组是顺序存储结构，拥有非常高效的随机访问能力；至于数组的劣势体现在插入和删除元素方面。
数组适合的是 读操作多、写操作少 的场景。
</code></pre><p><strong>链表</strong></p>
<pre><code>链表是一种在物理上非连续、非顺序的数据结构，由若干节点组成。
链表的优势在于灵活地进行插入和删除操作。
</code></pre><p>数组和链表是物理结构上的存储结构。与之相对的，则是数据存储的<strong>逻辑结构</strong>。</p>
<pre><code>线性逻辑结构：顺序表、栈、队列

非线性逻辑结构：树、图
</code></pre><p><strong>栈</strong></p>
<pre><code>栈中的元素只能先进后出。最早进入到元素存放的位置称为栈底，最后进入的元素位置称为栈顶。
栈既可以用数组实现，也可以用链表实现。
</code></pre><p><strong>队列</strong></p>
<pre><code>队列中的元素只能先进先出。最早进入到元素存放的位置称为队头，最后进入的元素位置称为队尾。
为方便入队操作，把队尾位置规定为最后入队元素的下一个位置。
用数组实现的队列可以采用循环队列的方式维持队列容量的恒定。
一直到 (队尾下标 + 1) % 队列长度 == 队头下标 时，代表队列已满。
</code></pre><p><strong>散列表</strong></p>
<pre><code>散列表也叫哈希表，这种数据结构提供了键(Key)和值(Value)的映射关系。
通过哈希函数将key转为下标存放value到数组中，实现读取操作的时间复杂度为O(1)。
解决哈希冲突的方法主要有两种：开放寻址和链表法。
开放寻址法，即当前对应的数组下标被占用时，寻找下一个空位。
链表法，即数组中的元素不仅是一个对象，还是一个链表的头节点。当映射发生冲突时，插入到链表中即可。
散列表扩容：
1、扩容，变为原来数组长度的两倍。
2、重新计算hash。因为长度扩大后，hash规则也发生了改版。
</code></pre><p><strong>树</strong></p>
<pre><code>树是n(n &gt;= 0)个节点的有限集合。当n = 0时，称为空树。在任意一个非空树种，有如下特点：
1、有且仅有一个特定的称为根的节点。
2、当n&gt;1时，其余节点可分为m(m&gt;0)个互不相交的有限集，每一个集合本身又是一个树，称为根的子树。
</code></pre><p><strong>二叉树</strong></p>
<pre><code>// 二叉树
二叉树是树的一种特殊形式。这种书的每个节点最多有2个节点。
二叉树节点的两个孩子节点，被称为左孩子和右孩子。孩子节点的顺序是固定的，不能混淆颠倒。

// 满二叉树
一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级，则称为满二叉树。

// 完全二叉树
对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为1到n；
如果这个树所有节点和同样深度的满二叉树的编号从1到n的节点位置相同，则成为完全二叉树。
</code></pre><p><strong>二叉查找树</strong></p>
<ol>
<li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值</li>
<li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值</li>
<li>左、右子树也都是二叉查找树</li>
</ol>
<pre><code>// 节点类
class TreeNode {
    constructor(data) {
        this.data = data;
        this.leftChild = null;
        this.rightChild = null;
    }
}

// 二叉树
class BinaryTree {
    constructor(arr) {
        if(!Array.isArray(arr) || arr.length &lt;= 0) 
            throw Error(&apos;BinaryTree Init went wrong!&apos;);
        else 
            this.root = this.createBinaryTree(arr);
    }

    createBinaryTree(arr) {
        // 如果没有节点了，则返回null
        if(arr.length &lt;= 0) return null;

        var node = null,
            data = arr.shift();

        if(data) {
            node = new TreeNode(data);
            node.leftChild = this.createBinaryTree(arr);
            node.rightChild = this.createBinaryTree(arr);
        } 

        return node;
    }

    // 前序遍历
    prevOrder(node) {
        if(!node) return;

        console.log(node.data);
        this.prevOrder(node.leftChild);
        this.prevOrder(node.rightChild);
    }

    // 中序遍历
    inOrder(node) {
        if(!node) return;

        this.inOrder(node.leftChild);
        console.log(node.data);
        this.inOrder(node.rightChild);
    }

    // 后序遍历
    postOrder(node) {
        if(!node) return;

        this.postOrder(node.leftChild);
        this.postOrder(node.rightChild);
        console.log(node.data);
    }

    // 层序遍历
    levelOrder() {
        var queue = [];
        queue.push(this.root);

        while(queue.length &gt; 0) {
            var node = queue.shift();
            console.log(node.data);
            if(node.leftChild) {
                queue.push(node.leftChild);
            }

            if(node.rightChild) {
                queue.push(node.rightChild);
            }
        }
    }
}

var bt =  new BinaryTree([3, 2, 9, null, null, 10, null, null, 8, null, 4]);
bt.prevOrder(bt.root); // 3 2 9 10 8 4
bt.inOrder(bt.root); // 9 2 10 3 8 4
bt.postOrder(bt.root); // 9 10 2 4 8 3
bt.levelOrder(); // 3 2 8 9 10 4
</code></pre><p><strong>二分查找</strong></p>
<pre><code>function binarySearch(arr, target) {
    var start = 0,
        end = arr.length - 1;

    while(start &lt;= end) {
        var mid = parseInt((start + end) / 2),
            cur = arr[mid];

        if(cur == target) {
            return mid;
        } else if(cur &gt; target) {
            end = mid - 1;
        } else if(cur &lt; target) {
            start = mid + 1;
        }
    }

    return -1;
}

var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
binarySearch(arr, 4); // 3
</code></pre><p><strong>冒泡排序</strong></p>
<pre><code>function bubbleSort(arr) {
    for(let i = 0; i &lt; arr.length - 1; i ++) {
        for(let j = 0; j &lt; arr.length - i - 1; j++) {
            if(arr[j] &gt; arr[j + 1]) {
                var [prev, next] = [arr[j], arr[j + 1]];
                arr[j] = next;
                arr[j + 1] = prev;
            }
        }
    }
}

var arr = [5, 8, 9, 3, 6, 4, 2, 1, 7];
bubbleSort(arr);
console.log(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><p><strong>快速排序</strong></p>
<pre><code>function quickSort(arr, start, end) {
    if(start &gt;= end) return;
    // 得到基准元素的位置
    var pivot = partition(arr, start, end);
    // 相对基准元素，分成两部分进行排序
    quickSort(arr, start, pivot - 1);
    quickSort(arr, pivot + 1, end);
}

function partition(arr, start, end) {
    var pivot = arr[start],
        mark = start;

    for(let i = start + 1; i &lt;= end; i++) {
        // 若当前元素小于基准元素，则将mark右移一位，交换它们的位置
        if(arr[i] &lt; pivot) {
            mark++;
            var tmp = arr[mark];
            arr[mark] = arr[i];
            arr[i] = tmp;
        }
    }

    // 交换基准元素和起始元素的位置
    arr[start] = arr[mark];
    arr[mark] = pivot;
    // 返回基准元素下标
    return mark;
}

var arr = [5, 8, 9, 3, 6, 4, 2, 1, 7];
quickSort(arr, 0, arr.length - 1);
console.log(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
        </div>
      </article>
    </div>
    <!-- Comments -->
    <div class="container">
      
<section id="comment">
  <!-- <h1 class="title">Comments</h1> -->

  
</section>


    </div>
    <!-- Pre or Next -->
    <div class="nav-links">
      
      
        <div class="nav-next">
          <a href="/2020/02/22/2020-read-list/" rel="prev">Older Posts <span class="meta-arraw meta-arraw-right"></span></a>
        </div>
      
    </div>
  </div>
</div>


  <!-- Footer -->
  <!-- Footer -->
<footer class="site-info">
  <div class="row inside-wrapper">
    <div class="col-1">
      <aside>
        <div class="widget-text">
          
          
          <a href="https://github.com/zllpCodes" class="icon icon-github" target="_blank">
            github</a>
          
          <a href="mailto: zllmypem@163.com" class="icon icon-mail" target="_blank">
            mail</a>
          
          
        </div>
      </aside>
    </div>
  </div>
  <p>
    <span>
      张琳琳个人网站 &copy;
      2020</span>
    
    <span class="split">|</span>
    <span>
      Powered by <a href="https://zhanglinlin.site" target="_blank">Zhang Linlin</a></span>
    
  </p>
</footer>

  <!-- After footer scripts -->
  <!-- scripts -->
<script src="/js/app.js"></script>





</body>

</html>
